''' This module provides a set of functions for post-processing road segmentation maps
generated by deep learning models, such as UNet. The primary goal is to refine the 
segmentation output by addressing issues like disconnected roads, false positives, 
and outliers.'''

import numpy as np
import matplotlib.pyplot as plt

from skimage.morphology import remove_small_objects, closing, square, diamond
from skimage.measure import label, regionprops
import networkx as nx
from skimage.morphology import skeletonize, binary_dilation, label
from skimage.draw import line
from scipy.spatial.distance import cdist

def estimate_local_width(region_mask, max_iterations=40):
    """
    Estimate the width of a road region by iteratively dilating its skeleton until it matches the road region.

    Steps:
    1. Skeletonize the input region to reduce it to a single-pixel-wide line (centerline of the road).
    2. Iteratively dilate the skeleton using square structuring elements of increasing size.
    3. Stop when the dilated skeleton completely covers the road region.
    4. Return the smallest width at which this condition is met.

    Args:
        region_mask (ndarray): Binary mask representing a single road region.
        max_iterations (int): Maximum number of dilation steps to attempt.

    Returns:
        int: Estimated road width for the region. Returns `max_iterations` if the road width exceeds the limit.
    """
    skeleton = skeletonize(region_mask)

    for width in range(1, max_iterations + 1):
        dilated_skeleton = binary_dilation(skeleton, footprint=square(width))
        if np.all(dilated_skeleton >= region_mask):
            return width

    return max_iterations

def build_global_graph(skeletons):
    """
    Build a global graph from skeletonized road regions.

    Steps:
    1. For each skeletonized region:
        - Add each pixel as a node in the graph.
        - Connect each node to its 8-connected neighbors if they are part of the skeleton.
    2. Perform boundary checks to ensure valid neighbor connections.

    Args:
        skeletons (list of ndarray): List of binary skeletonized road regions.

    Returns:
        networkx.Graph: Graph where nodes represent skeleton pixels and edges represent connections between them.
    """
    G = nx.Graph()

    for skeleton in skeletons:
        rows, cols = np.nonzero(skeleton)
        for r, c in zip(rows, cols):
            G.add_node((r, c))

            for dr in [-1, 0, 1]:
                for dc in [-1, 0, 1]:
                    if dr == 0 and dc == 0:
                        continue

                    neighbor = (r + dr, c + dc)
                    if 0 <= neighbor[0] < skeleton.shape[0] and 0 <= neighbor[1] < skeleton.shape[1]:
                        if skeleton[neighbor[0], neighbor[1]] == 1:
                            G.add_edge((r, c), neighbor)

    return G

def connect_edges_to_roads(binary_mask, max_distance=35, max_iterations=40):
    """
    Connect disconnected road segments that are close to each other based on skeletonized edges and estimated road width.

    Steps:
    1. Label connected components in the binary mask and sort them by size.
    2. Skeletonize each region and build a global graph representing all skeletonized roads.
    3. For each region:
        - Identify edge pixels (nodes with one neighbor).
        - Check for proximity to nodes in the global graph within `max_distance`.
        - Connect edge pixels to the nearest global graph node using a line.
    4. Dilate the connected regions to match the estimated road width and update the binary mask.

    Args:
        binary_mask (ndarray): Binary mask of the segmented roads.
        max_distance (int): Maximum distance to connect disconnected road segments.
        max_iterations (int): Maximum number of iterations for estimating road width.

    Returns:
        ndarray: Binary mask with connected roads.
    """
    connected_mask = np.zeros_like(binary_mask)
    connect = True

    while connect:
        connect = False
        skeletons = []

        labeled_mask = label(binary_mask | connected_mask)
        regions = regionprops(labeled_mask)
        sorted_regions = sorted(regions, key=lambda r: r.area)

        for region in sorted_regions:
            region_mask = (labeled_mask == region.label)
            skeleton = skeletonize(region_mask)
            skeletons.append(skeleton)

        global_graph = build_global_graph(skeletons)

        for region in sorted_regions:
            region_mask = (labeled_mask == region.label)
            road_width = estimate_local_width(region_mask, max_iterations)
            current_connection = np.zeros_like(binary_mask)
            skeleton = skeletonize(region_mask)
            region_graph = build_global_graph([skeleton])
            rows, cols = np.nonzero(skeleton)

            for r, c in zip(rows, cols):
                neighbors = list(region_graph.neighbors((r, c)))
                if len(neighbors) == 1:
                    dist_matrix = cdist([np.array([r, c])], np.array(list(global_graph.nodes())), metric='euclidean')[0]
                    close_pixels = np.array(list(global_graph.nodes()))[dist_matrix <= max_distance]
                    close_pixels = [tuple(pixel) for pixel in close_pixels if tuple(pixel) not in region_graph.nodes()]

                    if close_pixels:
                        closest_pixel = min(close_pixels, key=lambda px: np.linalg.norm(np.array(px) - np.array([r, c])))
                        rr, cc = line(r, c, closest_pixel[0], closest_pixel[1])
                        rr = np.clip(rr, 0, connected_mask.shape[0] - 1)
                        cc = np.clip(cc, 0, connected_mask.shape[1] - 1)
                        current_connection[rr, cc] = 1
                        # Smooth the region mask with the connection
                        current_connection = np.logical_or(skeleton,current_connection)
                        connect = True

            road_width = estimate_local_width(region_mask, max_iterations)
            dilated_region = binary_dilation(current_connection, footprint=square(road_width))
            connected_mask = np.logical_or(connected_mask, dilated_region)
            connected_mask
            break

    return np.logical_or(connected_mask, binary_mask)

def remove_false_positives(binary_mask, min_aspect_ratio=2.5, min_area=400):
    """
    Remove false positives such as houses, outlier pixels, or small structures.

    Steps:
    1. Label connected components in the binary mask.
    2. For each region:
        - Compute the aspect ratio using the major and minor axis lengths.
        - Retain regions that satisfy the minimum aspect ratio or area criteria.
    3. Return a filtered binary mask.

    Args:
        binary_mask (ndarray): Binary mask of the image.
        min_aspect_ratio (float): Minimum aspect ratio (major/minor axis) to retain regions.
        min_area (int): Minimum area for a region to be retained.

    Returns:
        ndarray: Binary mask with false positives removed.
    """
    labeled_mask = label(binary_mask)
    filtered_mask = np.zeros_like(binary_mask, dtype=bool)

    for region in regionprops(labeled_mask):
        major_axis = region.major_axis_length
        minor_axis = region.minor_axis_length

        if minor_axis == 0:
            aspect_ratio = float("inf")
        else:
            aspect_ratio = major_axis / minor_axis

        if aspect_ratio >= min_aspect_ratio or region.area >= min_area:
            filtered_mask[labeled_mask == region.label] = True

    return filtered_mask

def process_roads(raw_map, threshold=0.05, outlier_size=50, shape_size=5, min_aspect_ratio=2.5, max_connection_distance=35, display=False, connect=False):
    """
    Post-process the UNet output to refine road segmentation by removing outliers, false positives,
    and connecting disconnected roads if close enough.

    Steps:
    1. Threshold the raw prediction to generate a binary road map.
    2. Remove small objects below a specified size.
    3. Fill small holes and straighten roads using morphological closing.
    4. Remove false positives based on aspect ratio and area thresholds.
    5. Optionally connect disconnected road segments.
    6. Display intermediate steps if enabled.

    Args:
        raw_map (ndarray): Raw output of the road segmentation model.
        threshold (float): Threshold for binarizing the raw prediction.
        outlier_size (int): Minimum size of objects to retain.
        shape_size (int): Size of the structuring element for morphological closing.
        min_aspect_ratio (float): Minimum aspect ratio for retaining regions.
        max_connection_distance (int): Maximum distance to connect disconnected roads.
        display (bool): Whether to display intermediate steps.
        connect (bool): Whether to connect disconnected roads.

    Returns:
        tuple: Processed binary masks at different stages of refinement.
    """
    padding = 20

    binary_road_map = (raw_map > threshold).astype(np.uint8)
    binary_road_map = np.pad(binary_road_map, pad_width=padding, mode='constant', constant_values=0)
    cleaned_mask = remove_small_objects(binary_road_map > 0, min_size=outlier_size)
    filled_map = closing(cleaned_mask, square(shape_size))
    filled_map = closing(filled_map, diamond(shape_size))
    filtered_map_pad = remove_false_positives(filled_map, min_aspect_ratio=min_aspect_ratio, min_area=2)

    if connect:
        connected_map_pad = connect_edges_to_roads(filtered_map_pad, max_distance=max_connection_distance)
        connected_map = connected_map_pad[padding:-padding, padding:-padding]
    else:
        filtered_map = filtered_map[padding:-padding, padding:-padding]

    if display:
        if connect:
            ncols = 5
        else:
            ncols = 4
        fig, axes = plt.subplots(1, ncols, figsize=(15, 5))
        axes[0].imshow(binary_road_map, cmap='gray')
        axes[0].set_title("Binary Map")
        axes[0].axis('off')
        axes[1].imshow(cleaned_mask, cmap='gray')
        axes[1].set_title("Removed Small Objects")
        axes[1].axis('off')
        axes[2].imshow(filled_map, cmap='gray')
        axes[2].set_title("Filled Small Holes")
        axes[2].axis('off')
        axes[3].imshow(filtered_map_pad, cmap='gray')
        axes[3].set_title("After False Positive Removal")
        axes[3].axis('off')
        if connect:
            axes[4].imshow(connected_map_pad, cmap='gray')
            axes[4].set_title("Connected Roads")
            axes[4].axis('off')
        plt.tight_layout()
        plt.show()
    if connect:
        return connected_map, filtered_map_pad, filled_map, cleaned_mask, binary_road_map
    else:
        return filtered_map, filled_map, cleaned_mask, binary_road_map

def f1_loss_numpy(predictions, targets, epsilon=1e-7):
    """
    Compute F1 loss using NumPy.

    Args:
        predictions (np.ndarray): Predicted probabilities (float values between 0 and 1).
        targets (np.ndarray): Ground truth binary labels (0 or 1).
        threshold (float): Threshold to binarize predictions.
        epsilon (float): Small constant to avoid division by zero.

    Returns:
        float: F1 loss (1 - F1 score).
    """

    true_positive = np.sum(predictions * targets)
    false_positive = np.sum(predictions * (1 - targets))
    false_negative = np.sum((1 - predictions) * targets)

    precision = true_positive / (true_positive + false_positive + epsilon)
    recall = true_positive / (true_positive + false_negative + epsilon)

    f1_score = 2 * (precision * recall) / (precision + recall + epsilon)

    return 1 - f1_score